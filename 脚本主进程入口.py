import ctypes
import os
import sys
import time
import win32com.client

import 键盘操作
import 鼠标操作
from 升级 import 升级建筑
from 常用函数 import *
from 模拟器状态 import 雷电模拟器

#兼容pyinstaller的目录获取
if getattr(sys, 'frozen', False):
    当前文件所在目录 = sys._MEIPASS
else:
    当前文件所在目录 = os.path.dirname(__file__)
    print("当前获取op的目录为" + 当前文件所在目录)


# 加载注册com组件的dll
免注册dll = ctypes.windll.LoadLibrary(当前文件所在目录+R"\op-0.4.5_with_model\tools.dll")
dll目录=当前文件所在目录+R"\op-0.4.5_with_model\op_x64.dll"
是否注册成功 = 免注册dll.setupW(dll目录)
print("op免注册状态：" + str(是否注册成功))

# 创建op对象
op = win32com.client.Dispatch("op.opsoft")


def 窗口调用(消息队列, 配置信息=None):

    if 配置信息 is None:
        配置信息 = {}
    global op
    打印状态 = 消息队列.put

    # 解析字典中的配置信息,如果没有就使用默认设置
    雷电模拟器索引 = 配置信息.get("雷电模拟器索引", "0")
    部落冲突包名 = 配置信息.get("部落冲突包名", "com.supercell.clashofclans")
    一直执行 = 配置信息.get("一直执行", True)
    需要执行多少秒 = 配置信息.get("需要执行多少秒", 4 * 3600)
    是否开启刷墙 = 配置信息.get("是否开启刷墙", False)
    循环最大等待秒数 = 配置信息.get("循环最大等待秒数", 30)
    至少多少金币开始刷墙 = 配置信息.get("至少多少金币开始刷墙", 2000000)
    至少多少圣水开始刷墙 = 配置信息.get("至少多少圣水开始刷墙", 2700000)

    print(str(配置信息))
    打印状态("######本次运行设置######")

    # 逐行打印配置信息中的键值对
    for 键, 值 in 配置信息.items():
        打印状态(f"{键}: {值}")
    # 打印状态("######################")

    # 这是一些初始化信息，通常无需用户配置，故不写在配置文件
    进攻完毕次数 = 0
    找不到夜世界船的次数 = 0
    开始执行脚本时间 = time.time()
    当前金币 = -1
    当前圣水 = -1
    刷墙成功次数 = 0
    未绑定过窗口 = True
    雷电模拟器实例 = 雷电模拟器(int(雷电模拟器索引))


    目前脚本工作目录 = 当前文件所在目录
    鼠标 = 鼠标操作.鼠标控制器()
    键盘 = 键盘操作.键盘控制()

    def 点击(x, y, 延时=300):
        鼠标.移动到(x, y)
        鼠标.左键点击()
        op.Delay(延时)


    def 关闭游戏(原因=None):
        雷电模拟器实例.关闭模拟器中的应用(部落冲突包名)
        time.sleep(1)
        if 原因 is not None:
            打印状态(原因)

    重启游戏后不检测模拟器启动状态 = False  # 用于判断是否跳过前面的开模拟器,开游戏等操作,该变量会在循环超时,一直找不到夜世界船关闭游戏是置为False


    while True:  #循环进攻

        if 一直执行 is False:
            if time.time() - 开始执行脚本时间 > 需要执行多少秒:
                关闭游戏("到时间了")
                return


        if not 重启游戏后不检测模拟器启动状态:
            if not 雷电模拟器实例.模拟器是否启动():
                # 启动模拟器并打开游戏
                雷电模拟器实例.启动模拟器并打开应用(部落冲突包名)

                # 循环判断模拟器是否启动成功
                while not 雷电模拟器实例.模拟器是否启动():
                    打印状态("等待模拟器启动")
                    op.Delay(500)
                    continue
                打印状态("模拟器启动完毕")

                while 雷电模拟器实例.取绑定窗口句柄的下级窗口句柄() is None:
                    打印状态("等待进入安卓界面")
                    op.Delay(500)
                    continue
                op.Delay(30000)
                打印状态("已进入安卓系统")
                未绑定过窗口 = True

            else:
                雷电模拟器实例.打开应用(部落冲突包名)

            # 绑定窗口
            if 未绑定过窗口:
                # #
                # 是否成功绑定 = op.BindWindow(雷电模拟器实例.取顶层窗口句柄(), "dx2", "windows", "windows", 1)
                # op.Capture(0, 0, 2000, 2000, "a.bmp")
                #op插件bug,第一次截图可能会弹出报错,后面截图就好了,所以将报错信息设置为控制台输出
                op.SetShowErrorMsg(3)
                是否成功绑定 = op.BindWindow(雷电模拟器实例.取绑定窗口句柄的下级窗口句柄(), "opengl","normal","normal", 0)
                鼠标.绑定(雷电模拟器实例.取绑定窗口句柄(),"Windows消息模式")
                键盘.绑定(雷电模拟器实例.取绑定窗口句柄(),"Windows消息模式")

                # 等待绑定窗口完成
                op.Delay(500)
                打印状态("绑定窗口:" + str(是否成功绑定))

                #必须在绑定窗口后禁止操作模拟器,否则无法会导致无法截图
                # op.SetWindowState(雷电模拟器实例.取顶层窗口句柄(), 10)
                # 打印状态("禁止操作模拟器:")
                未绑定过窗口 = False

            #opengl模式后台截图和鼠标操作可以最小化，但是后台键盘有问题，所以也要确保不最小化
            # 判断窗口是否被最小化
            if op.GetWindowState(雷电模拟器实例.取顶层窗口句柄(), 3) == 1:
                打印状态("模拟器窗口已经最小化了,修改为还原状态")
                op.SetWindowState(雷电模拟器实例.取顶层窗口句柄(), 5)
            else:
                pass
                # 打印状态("没有最小化,脚本可以正常工作")


        打印状态("##########新一轮打鱼,目前是第" + str(进攻完毕次数) + f"次打鱼完毕了.##########")
        打印状态("等待进入夜世界主界面")

        # 判断循环是否超时间
        循环开始时间 = time.time()
        循环是否超时 = False
        升级建筑物致命错误次数 = 0


        #op.Capture(561,361,647,388, 目前脚本工作目录 + r"\img\开始查找.jpg")

        while True:  #判断登录状态循环
            op.Delay(500)

            result, x, y = op.FindPic(0, 0, 800, 600, 目前脚本工作目录 + r"\img\签到关闭按钮.jpg|"+目前脚本工作目录 + r"\img\签到关闭按钮1.bmp", "000000", 0.92, 0)
            if result != -1:
                打印状态("点击签到关闭按钮，继续检测登录情况")
                点击(x, y)
                op.Delay(500)


            result, x, y = op.FindPic(0, 0, 800, 600, 目前脚本工作目录 + r"\img\胜利之星确定按钮.jpg", "101010", 0.80, 0)
            if result != -1:
                打印状态("点击胜利之星确定按钮，继续检测登录情况")
                点击(x, y)
                op.Delay(1500)

            result, x, y = op.FindPic(0, 0, 800, 600, 目前脚本工作目录 + r"\img\国服弹窗叉.bmp", "101010",
                                      0.80, 0)
            if result != -1:
                打印状态("点击关闭钮，继续检测登录情况")
                点击(x, y)
                op.Delay(1500)


            #确保宝石图标出现稳定才判断为登录成功
            结果, x, y = op.FindPic(752, 9, 789, 154, 目前脚本工作目录 + r"\img\宝石.jpg", "000000", 0.92, 0)
            op.Delay(1500)
            隔一段时间后结果, x, y = op.FindPic(752, 9, 789, 154, 目前脚本工作目录 + r"\img\宝石.jpg", "000000", 0.92, 0)
            if 结果 != -1 and 隔一段时间后结果 != -1:
                打印状态(f"找到宝石图标，成功进入夜世界主界面")
                break

            结果, x, y = op.FindPic(0, 0, 800, 600, 目前脚本工作目录 + r"\img\点券图标.bmp", "101010", 0.9, 0)
            op.Delay(1500)
            隔一段时间后结果, x, y = op.FindPic(0, 0, 800, 600, 目前脚本工作目录 + r"\img\点券图标.bmp", "101010", 0.9, 0)
            if 结果 != -1 and 隔一段时间后结果 != -1:
                打印状态(f"找到点券图标成功进入夜世界主界面")
                break

            结果, x, y = op.FindPic(0, 0, 800, 600, 目前脚本工作目录 + r"\img\进攻图标.bmp", "101010", 0.92, 0)
            op.Delay(1500)
            隔一段时间后结果, x, y = op.FindPic(0, 0, 800, 600, 目前脚本工作目录 + r"\img\进攻图标.bmp", "101010", 0.92, 0)
            if 结果 != -1 and 隔一段时间后结果 != -1:
                打印状态(f"找到进攻图标成功进入夜世界主界面")
                break


            if time.time() - 循环开始时间 > 循环最大等待秒数:
                循环是否超时 = True
                关闭游戏("重启游戏,原因是一直没有成功登录！已经等待了" + str(循环最大等待秒数) + "秒")
                重启游戏后不检测模拟器启动状态 = False
                break

        #如果因为超时而关闭游戏,则回到循环开头,开游戏,进行下一次开游戏,打鱼等操作
        if 循环是否超时 is True:
            continue


        if 是否开启刷墙 is True:
            打印状态(f"当前刷墙时出现时致命性错误次数为{升级建筑物致命错误次数},刷墙成功了{刷墙成功次数}")


        #拉远视距
        for _ in range(20):
            键盘.按字符按压('f5')
            # op.KeyPressChar("f5")
        op.Delay(500)

        #获取当前金币圣水数量
        识别到的金币圣水字符串 = op.OcrEx(610, 15, 789, 89, "ffffff", 0.7)
        识别到的金币圣水字符串.replace(",", "")
        段落列表 = 识别到的金币圣水字符串.split('|')
        识别的列表 = []
        for 段落 in 段落列表:
            分割的片段 = 段落.split(',')
            识别的列表.append(分割的片段)

        try:
            if int(识别的列表[0][1]) < int(识别的列表[1][1]):
                当前金币 = int(识别的列表[0][2])
                当前圣水 = int(识别的列表[1][2])
            else:
                当前金币 = int(识别的列表[1][2])
                当前圣水 = int(识别的列表[0][2])
                打印状态(f"当前的金币为{识别的列表[1][2]},圣水为{识别的列表[0][2]}")
        except:
            打印状态("本次识别金币,圣水出错,当前未更新金币圣水,将打印上一次识别的结果或默认值")

        打印状态(f"当前的金币为{当前金币},圣水为{当前圣水}")

        是否因为多次找不到船而关闭了游戏 = False
        #通过船判断领取圣水地方
        a, x, y = op.FindPic(0, 0, 2000, 2000, 目前脚本工作目录 + r"\img\船.jpg", "000000", 0.5, 0)
        if x != -1:
            # 点击车
            点击(x - 79, y + 35)
            # 点击收集
            点击(605, 471)
            op.Delay(1000)
            # 关闭领取界面
            点击(699, 103)
        else:
            打印状态("没有找到夜世界的船")
            找不到夜世界船的次数 += 1
            if 找不到夜世界船的次数 > 10:
                关闭游戏("关闭游戏,原因:一直找不到夜世界的船")
                找不到夜世界船的次数=0
                是否因为多次找不到船而关闭了游戏 = True
                重启游戏后不检测模拟器启动状态 = False
        #多次找不到船,游戏已经关闭,回到循环开始,重新进行下一次打鱼
        if 是否因为多次找不到船而关闭了游戏:
            continue

        # 必须升级建筑物在找夜世界船后面,因为升级建筑会去第二世界,导致找不到船
        while 进攻完毕次数 % 3 == 0:

            if 是否开启刷墙 is False:
                打印状态("刷墙已关闭,跳过刷墙")
                break

            if 当前金币 < 至少多少金币开始刷墙:
                打印状态(f"留{至少多少金币开始刷墙}金币,不刷墙了")
                break

            if 当前圣水 < 至少多少圣水开始刷墙:
                打印状态(f"留{至少多少圣水开始刷墙}圣水,不刷墙了")
                break

            if 升级建筑物致命错误次数 > 10:
                打印状态("多次升级建筑失败,本次运行跳过升级建筑")
                break
            else:
                # 打印状态("开始刷墙")
                升级信息, 是否致命错误, 建筑物需要资源, 资源类型 = 升级建筑(op,鼠标,打印状态, "城墙",)
                # print(升级信息, 是否致命错误, 建筑物需要资源, 资源类型)
                打印状态(升级信息)
                if 是否致命错误 is True:
                    升级建筑物致命错误次数 += 1

                if "升级了" in 升级信息:
                    刷墙成功次数 += 1
                    continue
                else:
                    #刷墙完毕,或者不能刷墙退出升级建筑判断,等待一下,因为有时候游戏没反应过来,到时出兵失败
                    op.Delay(500)
                    break


        打印状态("开始搜索敌人,准备进攻")
        #点击进攻
        点击(58, 536, 700)


        # 判断循环是否超时间
        循环开始时间 = time.time()
        循环是否超时 = False

        #判断是否成功打开进攻，否则再打开一次(如果没找到开始进攻图标则等待一会再点一次
        while True:

            if time.time() - 循环开始时间 > 5:
                循环是否超时 = True
                关闭游戏("关闭游戏,原因:多次打开进攻界面失败")
                op.Delay(1000)
                重启游戏后不检测模拟器启动状态 = False
                break

            _, x, y=op.FindPic(0,0,800,600, 目前脚本工作目录 + r"\img\开始进攻.jpg|"+目前脚本工作目录 + r"\img\开始查找.jpg", "000000", 0.50, 0)

            if x!=-1:
                break


            打印状态("打开进攻界面失败")
            # 点击进攻
            点击(58, 536)
            op.Delay(1000)

        # 如果因为超时而关闭游戏,则回到循环开头,开游戏,进行下一次开游戏,打鱼等操作
        if 循环是否超时 is True:
            continue

        # 打印状态("1124e1")
        #点击立即寻找
        点击(600, 380)

        # 判断循环是否进入战斗界面
        循环开始时间 = time.time()
        循环是否超时 = False
        while True:
            if time.time() - 循环开始时间 > 循环最大等待秒数:
                循环是否超时 = True
                关闭游戏(
                        "重启游戏,原因是一直卡白云或者某处,导致一直没进入战斗界面！已经等待了" + str(
                        循环最大等待秒数) + "秒")
                重启游戏后不检测模拟器启动状态 = False
                break


            _, x, y = op.FindPic(132,502,757,616, 目前脚本工作目录 + r"\img\更换兵种箭头.bmp|"+目前脚本工作目录 + r"\img\更换兵种箭头1.bmp",
                                 "000000", 0.6, 0)

            if x == -1:
                continue
            else:
                打印状态("开始进攻")
                break

        # 如果因为超时而关闭游戏,则回到循环开头,进行下一次开游戏,打鱼等操作
        if 循环是否超时 is True:
            continue



       # 18, 21
        点击(x-18, y-21)

        points = [(14, 309), (366, 37), (764, 311), (375, 473)]
        for 出兵所在直线 in range(4):
            line_equations = 计算相邻点所确定的直线(points)
            出兵点 = 取直线上的随机点(line_equations, [(14, 366), (366, 764), (375, 764), (14, 375)], 出兵所在直线, 9)
            for 出兵点的元组 in 出兵点:
                点击(出兵点的元组[0], 出兵点的元组[1], 100)

        #点击选择英雄

        if 部落冲突包名=="com.supercell.clashofclans":
        #国际服逻辑
            点击(47, 545)
        else:
            点击(94,551)


        #出英雄
        点击(55, 299)

        #放英雄技能
        op.Delay(3000)
        点击(42, 554)


        #放女巫技能
        while True:
            _,x, y=op.FindPic(4, 477, 800, 535, 目前脚本工作目录 + r"\img\紫色色块.bmp", "000000", 0.95, 0)
            op.Delay(random.randint(500, 1000))
            if x<0:
                break
            打印状态("释放兵种技能")
            点击(x, y+40)


        第二场战斗是否已经开始 = False
        循环开始时间 = time.time()
        循环是否超时 = False
        while True:  #本循环有两个判断,判断是否存在第二次战斗和是否出现回营按钮
            if time.time() - 循环开始时间 > 180:
                循环是否超时 = True
                关闭游戏("重启游戏,原因为因为战斗好久没结束,或一直没有开始第二场战斗.已经等待了" + str(180) + "秒")
                重启游戏后不检测模拟器启动状态 = False
                break

            #如果第二次战斗还没打就判断两个,否则就一直判断回营图标的出现
            if 第二场战斗是否已经开始 == False:
                _, x, y = op.FindPic(132,502,757,616, 目前脚本工作目录 + r"\img\更换兵种箭头.bmp|"+目前脚本工作目录 + r"\img\更换兵种箭头1.bmp",
                                                     "000000", 0.6, 3)

                if x != -1:
                    op.Delay(500)
                    循环开始时间 = time.time()  #因为开始第二场战斗,重置等待回营的超时时间,从现在重新计算等待时间
                    第二场战斗是否已经开始 = True  #确保下一次不判断,
                    打印状态("第二场次战斗")

                    op.Delay(2500)


                    点击(x - 18, y - 21)

                    points = [(14, 309), (366, 37), (764, 311), (375, 473)]
                    for 出兵所在直线 in range(4):
                        line_equations = 计算相邻点所确定的直线(points)
                        出兵点 = 取直线上的随机点(line_equations, [(14, 366), (366, 764), (375, 764), (14, 375)],
                                                  出兵所在直线, 9)
                        for 出兵点的元组 in 出兵点:
                            点击(出兵点的元组[0], 出兵点的元组[1], 100)

                    # 点击选择英雄
                    if 部落冲突包名 == "com.supercell.clashofclans":
                        # 国际服逻辑
                        点击(47, 545)
                    else:
                        点击(94, 551)

                    # 出英雄
                    点击(55, 299)

                    # 放英雄技能
                    op.Delay(3000)
                    点击(42, 554)

                    # 放女巫技能
                    while True:
                        _, x, y = op.FindPic(4, 477, 800, 535, 目前脚本工作目录 + r"\img\紫色色块.bmp", "000000", 0.95,
                                             0)
                        op.Delay(random.randint(500, 1000))
                        if x < 0:
                            break
                        打印状态("释放兵种技能")
                        点击(x, y + 40)

            _, 回营x, 回营y = op.FindPic(0, 0, 2000, 2000, 目前脚本工作目录 + r"\img\回营.jpg", "0", 0.6, 0)
            if 回营x == -1:
                continue
            else:
                打印状态("回营")
                点击(回营x, 回营y)
                进攻完毕次数 += 1
                打印状态("进攻完毕了" + str(进攻完毕次数) + "次")
                重启游戏后不检测模拟器启动状态 = True
                点击(回营x, 回营y)
                #多点击一次回营,以免速度太快没点到
                op.Delay(500)
                点击(回营x, 回营y)
                break

        # 如果因为超时而关闭游戏,则回到循环开头,进行下一次开游戏,打鱼等操作
        if 循环是否超时 is True:
            continue
